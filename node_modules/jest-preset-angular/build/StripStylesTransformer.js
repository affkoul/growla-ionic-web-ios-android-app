"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = exports.version = exports.name = void 0;
var STYLES = 'styles';
var COMPONENT = 'Component';
var TRANSFORM_IN_DECORATOR_PROPS = [STYLES];
exports.name = 'angular-component-strip-styles';
exports.version = 1;
function factory(cs) {
    var ts = cs.compilerModule;
    function isInDecoratorPropertyAssignmentToTransform(node) {
        return getInDecoratorPropertyAssignmentsToTransform(node).length > 0;
    }
    function getInDecoratorPropertyAssignmentsToTransform(node) {
        if (!ts.isClassDeclaration(node) || !node.decorators) {
            return [];
        }
        return node.decorators
            .map(function (dec) { return dec.expression; })
            .filter(ts.isCallExpression)
            .filter(function (callExpr) {
            return ts.isIdentifier(callExpr.expression) && callExpr.expression.getText() === COMPONENT;
        })
            .reduce(function (acc, nxtCallExpr) {
            return Array.prototype.concat.apply(acc, nxtCallExpr.arguments.filter(ts.isObjectLiteralExpression).reduce(function (acc, nxtArg) {
                return Array.prototype.concat.apply(acc, nxtArg.properties
                    .filter(ts.isPropertyAssignment)
                    .filter(function (propAss) {
                    return ts.isIdentifier(propAss.name) && TRANSFORM_IN_DECORATOR_PROPS.includes(propAss.name.text);
                }));
            }, []));
        }, []);
    }
    function transformStylesAssignmentForJest(node) {
        var mutableNode = ts.getMutableClone(node);
        var assignments = getInDecoratorPropertyAssignmentsToTransform(mutableNode);
        assignments.forEach(function (assignment) {
            if (assignment.name.text === STYLES) {
                assignment.initializer = ts.createArrayLiteral();
            }
        });
        return mutableNode;
    }
    function createVisitor(ctx, _) {
        var visitor = function (node) {
            if (isInDecoratorPropertyAssignmentToTransform(node)) {
                return transformStylesAssignmentForJest(node);
            }
            else {
                return ts.visitEachChild(node, visitor, ctx);
            }
        };
        return visitor;
    }
    return function (ctx) { return function (sf) {
        return ts.visitNode(sf, createVisitor(ctx, sf));
    }; };
}
exports.factory = factory;
