"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = exports.version = exports.name = void 0;
var TransformUtils_1 = require("./TransformUtils");
var TEMPLATE_URL = 'templateUrl';
var STYLE_URLS = 'styleUrls';
var TEMPLATE = 'template';
var REQUIRE = 'require';
var TRANSFORM_PROPS = [TEMPLATE_URL, STYLE_URLS];
exports.name = 'angular-component-inline-files';
exports.version = 1;
function factory(cs) {
    var ts = cs.compilerModule;
    var createStringLiteral = TransformUtils_1.getCreateStringLiteral(ts);
    function isPropertyAssignmentToTransform(node) {
        return ts.isPropertyAssignment(node) && ts.isIdentifier(node.name) && TRANSFORM_PROPS.includes(node.name.text);
    }
    function transfromPropertyAssignmentForJest(node) {
        var mutableAssignment = ts.getMutableClone(node);
        var assignmentNameText = mutableAssignment.name.text;
        switch (assignmentNameText) {
            case TEMPLATE_URL:
                var pathLiteral = mutableAssignment.initializer;
                if (ts.isStringLiteral(pathLiteral)) {
                    if (pathLiteral.text && !pathLiteral.text.match(/^(\.\/|\.\.\/|\/)/)) {
                        pathLiteral = createStringLiteral("./" + pathLiteral.text);
                    }
                }
                var requireCall = ts.createCall(ts.createIdentifier(REQUIRE), undefined, [pathLiteral]);
                mutableAssignment.name = ts.createIdentifier(TEMPLATE);
                mutableAssignment.initializer = requireCall;
                break;
            case STYLE_URLS:
                mutableAssignment.initializer = ts.createArrayLiteral();
                break;
            default:
                break;
        }
        return mutableAssignment;
    }
    function createVisitor(ctx, _) {
        var visitor = function (node) {
            var resultNode = node;
            if (isPropertyAssignmentToTransform(node)) {
                resultNode = transfromPropertyAssignmentForJest(node);
            }
            resultNode = ts.visitEachChild(resultNode, visitor, ctx);
            return resultNode;
        };
        return visitor;
    }
    return function (ctx) { return function (sf) {
        return ts.visitNode(sf, createVisitor(ctx, sf));
    }; };
}
exports.factory = factory;
