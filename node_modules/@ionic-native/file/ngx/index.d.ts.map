{"version":3,"file":"index.d.ts","sources":["index.d.ts"],"names":[],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { IonicNativePlugin } from '@ionic-native/core';\nexport interface IFile extends Blob {\n    /**\n     * Name of the file, without path information\n     */\n    name: string;\n    /**\n     * Last modified date\n     */\n    lastModified: number;\n    /**\n     * Last modified date\n     */\n    lastModifiedDate: number;\n    /**\n     * Size in bytes\n     */\n    size: number;\n    /**\n     * File mime type\n     */\n    type: string;\n    localURL: string;\n    start: number;\n    end: number;\n    /**\n     * Returns a \"slice\" of the file. Since Cordova Files don't contain the actual\n     * content, this really returns a File with adjusted start and end.\n     * Slices of slices are supported.\n     * @param start {Number} The index at which to start the slice (inclusive).\n     * @param end {Number} The index at which to end the slice (exclusive).\n     */\n    slice(start: number, end: number): Blob;\n}\nexport interface LocalFileSystem {\n    /**\n     * Used for storage with no guarantee of persistence.\n     */\n    TEMPORARY: number;\n    /**\n     * Used for storage that should not be removed by the user agent without application or user permission.\n     */\n    PERSISTENT: number;\n    /**\n     * Requests a filesystem in which to store application data.\n     * @param type Whether the filesystem requested should be persistent, as defined above. Use one of TEMPORARY or\n     *   PERSISTENT.\n     * @param size This is an indicator of how much storage space, in bytes, the application expects to need.\n     * @param successCallback The callback that is called when the user agent provides a filesystem.\n     * @param errorCallback A callback that is called when errors happen, or when the request to obtain the filesystem is\n     *   denied.\n     */\n    requestFileSystem(type: number, size: number, successCallback: FileSystemCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Allows the user to look up the Entry for a file or directory referred to by a local URL.\n     * @param url A URL referring to a local file in a filesystem accessable via this API.\n     * @param successCallback A callback that is called to report the FileEntry to which the supplied URL refers.\n     * @param errorCallback A callback that is called when errors happen, or when the request to obtain the Entry is\n     *   denied.\n     */\n    resolveLocalFileSystemURL(url: string, successCallback: FileEntryCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * see requestFileSystem.\n     */\n    webkitRequestFileSystem(type: number, size: number, successCallback: FileSystemCallback, errorCallback?: ErrorCallback): void;\n}\nexport interface Metadata {\n    /**\n     * This is the time at which the file or directory was last modified.\n     * @readonly\n     */\n    modificationTime: Date;\n    /**\n     * The size of the file, in bytes. This must return 0 for directories.\n     * @readonly\n     */\n    size: number;\n}\nexport interface Flags {\n    /**\n     * Used to indicate that the user wants to create a file or directory if it was not previously there.\n     */\n    create?: boolean;\n    /**\n     * By itself, exclusive must have no effect. Used with create, it must cause getFile and getDirectory to fail if the\n     * target path already exists.\n     */\n    exclusive?: boolean;\n}\n/**\n * This export interface represents a file system.\n */\nexport interface FileSystem {\n    /**\n     * This is the name of the file system. The specifics of naming filesystems is unspecified, but a name must be unique\n     * across the list of exposed file systems.\n     * @readonly\n     */\n    name: string;\n    /**\n     * The root directory of the file system.\n     * @readonly\n     */\n    root: DirectoryEntry;\n    toJSON(): string;\n    encodeURIPath(path: string): string;\n}\nexport interface Entry {\n    /**\n     * Entry is a file.\n     */\n    isFile: boolean;\n    /**\n     * Entry is a directory.\n     */\n    isDirectory: boolean;\n    /**\n     * Look up metadata about this entry.\n     * @param successCallback A callback that is called with the time of the last modification.\n     * @param errorCallback ErrorCallback A callback that is called when errors happen.\n     */\n    getMetadata(successCallback: MetadataCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Set the metadata of the entry.\n     * @param successCallback {Function} is called with a Metadata object\n     * @param errorCallback {Function} is called with a FileError\n     * @param metadataObject {Metadata} keys and values to set\n     */\n    setMetadata(successCallback: MetadataCallback, errorCallback: ErrorCallback, metadataObject: Metadata): void;\n    /**\n     * The name of the entry, excluding the path leading to it.\n     */\n    name: string;\n    /**\n     * The full absolute path from the root to the entry.\n     */\n    fullPath: string;\n    /**\n     * The file system on which the entry resides.\n     */\n    filesystem: FileSystem;\n    /**\n     * an alternate URL which can be used by native webview controls, for example media players.\n     */\n    nativeURL: string;\n    /**\n     * Look up metadata about this entry.\n     * @param successCallback A callback that is called with the time of the last modification.\n     * @param errorCallback ErrorCallback A callback that is called when errors happen.\n     */\n    getMetadata(successCallback: MetadataCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Set the metadata of the entry.\n     * @param successCallback {Function} is called with a Metadata object\n     * @param errorCallback {Function} is called with a FileError\n     * @param metadataObject {Metadata} keys and values to set\n     */\n    setMetadata(successCallback: MetadataCallback, errorCallback: ErrorCallback, metadataObject: Metadata): void;\n    /**\n     * Move an entry to a different location on the file system. It is an error to try to:\n     *\n     * <ui>\n     * <li>move a directory inside itself or to any child at any depth;</li>\n     * <li>move an entry into its parent if a name different from its current one isn't provided;</li>\n     * <li>move a file to a path occupied by a directory;</li>\n     * <li>move a directory to a path occupied by a file;</li>\n     * <li>move any element to a path occupied by a directory which is not empty.</li>\n     * <ul>\n     *\n     * A move of a file on top of an existing file must attempt to delete and replace that file.\n     * A move of a directory on top of an existing empty directory must attempt to delete and replace that directory.\n     */\n    moveTo(parent: DirectoryEntry, newName?: string, successCallback?: EntryCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Copy an entry to a different location on the file system. It is an error to try to:\n     *\n     * <ul>\n     * <li> copy a directory inside itself or to any child at any depth;</li>\n     * <li> copy an entry into its parent if a name different from its current one isn't provided;</li>\n     * <li> copy a file to a path occupied by a directory;</li>\n     * <li> copy a directory to a path occupied by a file;</li>\n     * <li> copy any element to a path occupied by a directory which is not empty.</li>\n     * <li> A copy of a file on top of an existing file must attempt to delete and replace that file.</li>\n     * <li> A copy of a directory on top of an existing empty directory must attempt to delete and replace that\n     * directory.</li>\n     * </ul>\n     *\n     * Directory copies are always recursive--that is, they copy all contents of the directory.\n     */\n    copyTo(parent: DirectoryEntry, newName?: string, successCallback?: EntryCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Returns a URL that can be used to identify this entry. Unlike the URN defined in [FILE-API-ED], it has no specific\n     * expiration; as it describes a location on disk, it should be valid at least as long as that location exists.\n     */\n    toURL(): string;\n    /**\n     * Return a URL that can be passed across the bridge to identify this entry.\n     * @return string URL that can be passed across the bridge to identify this entry\n     */\n    toInternalURL(): string;\n    /**\n     * Deletes a file or directory. It is an error to attempt to delete a directory that is not empty. It is an error to\n     * attempt to delete the root directory of a filesystem.\n     * @param successCallback A callback that is called on success.\n     * @param errorCallback A callback that is called when errors happen.\n     */\n    remove(successCallback: VoidCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Look up the parent DirectoryEntry containing this Entry. If this Entry is the root of its filesystem, its parent\n     * is itself.\n     * @param successCallback A callback that is called to return the parent Entry.\n     * @param errorCallback A callback that is called when errors happen.\n     */\n    getParent(successCallback: DirectoryEntryCallback, errorCallback?: ErrorCallback): void;\n}\n/**\n * This export interface represents a directory on a file system.\n */\nexport interface DirectoryEntry extends Entry {\n    /**\n     * Creates a new DirectoryReader to read Entries from this Directory.\n     */\n    createReader(): DirectoryReader;\n    /**\n     * Creates or looks up a file.\n     * @param path Either an absolute path or a relative path from this DirectoryEntry to the file to be looked up or\n     *   created. It is an error to attempt to create a file whose immediate parent does not yet exist.\n     * @param options\n     *     <ul>\n     *     <li>If create and exclusive are both true, and the path already exists, getFile must fail.</li>\n     *     <li>If create is true, the path doesn't exist, and no other error occurs, getFile must create it as a\n     *   zero-length file and return a corresponding FileEntry.</li>\n     *     <li>If create is not true and the path doesn't exist, getFile must fail.</li>\n     *     <li>If create is not true and the path exists, but is a directory, getFile must fail.</li>\n     *     <li>Otherwise, if no other error occurs, getFile must return a FileEntry corresponding to path.</li>\n     *     </ul>\n     * @param successCallback A callback that is called to return the File selected or created.\n     * @param errorCallback A callback that is called when errors happen.\n     */\n    getFile(path: string, options?: Flags, successCallback?: FileEntryCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Creates or looks up a directory.\n     * @param path Either an absolute path or a relative path from this DirectoryEntry to the directory to be looked up\n     *   or created. It is an error to attempt to create a directory whose immediate parent does not yet exist.\n     * @param options\n     *     <ul>\n     *     <li>If create and exclusive are both true and the path already exists, getDirectory must fail.</li>\n     *     <li>If create is true, the path doesn't exist, and no other error occurs, getDirectory must create and return\n     *   a corresponding DirectoryEntry.</li>\n     *     <li>If create is not true and the path doesn't exist, getDirectory must fail.</li>\n     *     <li>If create is not true and the path exists, but is a file, getDirectory must fail.</li>\n     *     <li>Otherwise, if no other error occurs, getDirectory must return a DirectoryEntry corresponding to path.</li>\n     *     </ul>\n     * @param successCallback   A callback that is called to return the DirectoryEntry selected or created.\n     * @param errorCallback A callback that is called when errors happen.\n     *\n     */\n    getDirectory(path: string, options?: Flags, successCallback?: DirectoryEntryCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Deletes a directory and all of its contents, if any. In the event of an error [e.g. trying to delete a directory\n     * that contains a file that cannot be removed], some of the contents of the directory may be deleted. It is an error\n     * to attempt to delete the root directory of a filesystem.\n     * @param successCallback A callback that is called on success.\n     * @param errorCallback A callback that is called when errors happen.\n     */\n    removeRecursively(successCallback: VoidCallback, errorCallback?: ErrorCallback): void;\n}\n/**\n * This export interface lets a user list files and directories in a directory. If there are no additions to or\n * deletions from a directory between the first and last call to readEntries, and no errors occur, then:\n * <ul>\n * <li> A series of calls to readEntries must return each entry in the directory exactly once.</li>\n * <li> Once all entries have been returned, the next call to readEntries must produce an empty array.</li>\n * <li> If not all entries have been returned, the array produced by readEntries must not be empty.</li>\n * <li> The entries produced by readEntries must not include the directory itself [\".\"] or its parent [\"..\"].</li>\n * </ul>\n */\nexport interface DirectoryReader {\n    localURL: string;\n    hasReadEntries: boolean;\n    /**\n     * Read the next block of entries from this directory.\n     * @param successCallback Called once per successful call to readEntries to deliver the next previously-unreported\n     *   set of Entries in the associated Directory. If all Entries have already been returned from previous invocations\n     *   of readEntries, successCallback must be called with a zero-length array as an argument.\n     * @param errorCallback A callback indicating that there was an error reading from the Directory.\n     */\n    readEntries(successCallback: EntriesCallback, errorCallback?: ErrorCallback): void;\n}\n/**\n * This export interface represents a file on a file system.\n */\nexport interface FileEntry extends Entry {\n    /**\n     * Creates a new FileWriter associated with the file that this FileEntry represents.\n     * @param successCallback A callback that is called with the new FileWriter.\n     * @param errorCallback A callback that is called when errors happen.\n     */\n    createWriter(successCallback: FileWriterCallback, errorCallback?: ErrorCallback): void;\n    /**\n     * Returns a File that represents the current state of the file that this FileEntry represents.\n     * @param successCallback A callback that is called with the File.\n     * @param errorCallback A callback that is called when errors happen.\n     */\n    file(successCallback: FileCallback, errorCallback?: ErrorCallback): void;\n}\n/**\n * When requestFileSystem() succeeds, the following callback is made.\n */\nexport declare type FileSystemCallback = (filesystem: FileSystem) => void;\n/**\n * This export interface is the callback used to look up Entry objects.\n */\nexport declare type EntryCallback = (entry: Entry) => void;\n/**\n * This export interface is the callback used to look up FileEntry objects.\n */\nexport declare type FileEntryCallback = (entry: FileEntry) => void;\n/**\n * This export interface is the callback used to look up DirectoryEntry objects.\n */\nexport declare type DirectoryEntryCallback = (entry: DirectoryEntry) => void;\n/**\n * When readEntries() succeeds, the following callback is made.\n */\nexport declare type EntriesCallback = (entries: Entry[]) => void;\n/**\n * This export interface is the callback used to look up file and directory metadata.\n */\nexport declare type MetadataCallback = (metadata: Metadata) => void;\n/**\n * This export interface is the callback used to create a FileWriter.\n */\nexport declare type FileWriterCallback = (fileWriter: FileWriter) => void;\n/**\n * This export interface is the callback used to obtain a File.\n */\nexport declare type FileCallback = (file: IFile) => void;\n/**\n * This export interface is the generic callback used to indicate success of an asynchronous method.\n */\nexport declare type VoidCallback = () => void;\n/**\n * When an error occurs, the following callback is made.\n */\nexport declare type ErrorCallback = (err: FileError) => void;\nexport interface RemoveResult {\n    success: boolean;\n    fileRemoved: Entry;\n}\n/** @hidden */\nexport declare class FileSaver extends EventTarget {\n    /**\n     * When the FileSaver constructor is called, the user agent must return a new FileSaver object with readyState set to\n     * INIT. This constructor must be visible when the script's global object is either a Window object or an object\n     * implementing the WorkerUtils interface.\n     */\n    constructor(data: Blob);\n    /**\n     * When the abort method is called, user agents must run the steps below:\n     * <ol>\n     * <li> If readyState == DONE or readyState == INIT, terminate this overall series of steps without doing anything\n     * else. </li>\n     * <li> Set readyState to DONE. </li>\n     * <li> If there are any tasks from the object's FileSaver task source in one of the task queues, then remove those\n     * tasks. </li>\n     * <li> Terminate the write algorithm being processed. </li>\n     * <li> Set the error attribute to a DOMError object of type \"AbortError\". </li>\n     * <li> Fire a progress event called abort </li>\n     * <li> Fire a progress event called write end </li>\n     * <li> Terminate this algorithm. </li>\n     * </ol>\n     */\n    abort(): void;\n    /**\n     * The blob is being written.\n     * @readonly\n     */\n    INIT: number;\n    /**\n     * The object has been constructed, but there is no pending write.\n     * @readonly\n     */\n    WRITING: number;\n    /**\n     * The entire Blob has been written to the file, an error occurred during the write, or the write was aborted using\n     * abort(). The FileSaver is no longer writing the blob.\n     * @readonly\n     */\n    DONE: number;\n    /**\n     * The FileSaver object can be in one of 3 states. The readyState attribute, on getting, must return the current\n     * state, which must be one of the following values:\n     * <ul>\n     * <li>INIT</li>\n     * <li>WRITING</li>\n     * <li>DONE</li>\n     * <ul>\n     * @readonly\n     */\n    readyState: number;\n    /**\n     * The last error that occurred on the FileSaver.\n     * @readonly\n     */\n    error: Error;\n    /**\n     * Handler for write start events\n     */\n    onwritestart: (event: ProgressEvent) => void;\n    /**\n     * Handler for progress events.\n     */\n    onprogress: (event: ProgressEvent) => void;\n    /**\n     * Handler for write events.\n     */\n    onwrite: (event: ProgressEvent) => void;\n    /**\n     * Handler for abort events.\n     */\n    onabort: (event: ProgressEvent) => void;\n    /**\n     * Handler for error events.\n     */\n    onerror: (event: ProgressEvent) => void;\n    /**\n     * Handler for write end events.\n     */\n    onwriteend: (event: ProgressEvent) => void;\n    /**\n     * When the FileSaver constructor is called, the user agent must return a new FileSaver object with readyState set to\n     * INIT. This constructor must be visible when the script's global object is either a Window object or an object\n     * implementing the WorkerUtils interface.\n     */\n    constructor(data: Blob);\n    /**\n     * When the abort method is called, user agents must run the steps below:\n     * <ol>\n     * <li> If readyState == DONE or readyState == INIT, terminate this overall series of steps without doing anything\n     * else. </li>\n     * <li> Set readyState to DONE. </li>\n     * <li> If there are any tasks from the object's FileSaver task source in one of the task queues, then remove those\n     * tasks. </li>\n     * <li> Terminate the write algorithm being processed. </li>\n     * <li> Set the error attribute to a DOMError object of type \"AbortError\". </li>\n     * <li> Fire a progress event called abort </li>\n     * <li> Fire a progress event called writeend </li>\n     * <li> Terminate this algorithm. </li>\n     * </ol>\n     */\n    abort(): void;\n}\n/**\n * @hidden\n * This interface expands on the FileSaver interface to allow for multiple write actions, rather than just saving a\n *   single Blob.\n */\nexport declare class FileWriter extends FileSaver {\n    /**\n     * The byte offset at which the next write to the file will occur. This must be no greater than length.\n     * A newly-created FileWriter must have position set to 0.\n     */\n    position: number;\n    /**\n     * The length of the file. If the user does not have read access to the file, this must be the highest byte offset at\n     * which the user has written.\n     */\n    length: number;\n    /**\n     * Write the supplied data to the file at position.\n     * @param data The blob to write.\n     */\n    write(data: ArrayBuffer | Blob | string): void;\n    /**\n     * Seek sets the file position at which the next write will occur.\n     * @param offset If nonnegative, an absolute byte offset into the file. If negative, an offset back from the end of\n     *   the file.\n     */\n    seek(offset: number): void;\n    /**\n     * Changes the length of the file to that specified. If shortening the file, data beyond the new length must be\n     * discarded. If extending the file, the existing data must be zero-padded up to the new length.\n     * @param size The size to which the length of the file is to be adjusted, measured in bytes.\n     */\n    truncate(size: number): void;\n}\nexport interface IWriteOptions {\n    replace?: boolean;\n    append?: boolean;\n    truncate?: number;\n}\n/** @hidden */\nexport declare class FileError {\n    static NOT_FOUND_ERR: number;\n    static SECURITY_ERR: number;\n    static ABORT_ERR: number;\n    static NOT_READABLE_ERR: number;\n    static ENCODING_ERR: number;\n    static NO_MODIFICATION_ALLOWED_ERR: number;\n    static INVALID_STATE_ERR: number;\n    static SYNTAX_ERR: number;\n    static INVALID_MODIFICATION_ERR: number;\n    static QUOTA_EXCEEDED_ERR: number;\n    static TYPE_MISMATCH_ERR: number;\n    static PATH_EXISTS_ERR: number;\n    /** Error code */\n    code: number;\n    message: string;\n    constructor(code: number);\n}\n/** @hidden */\nexport declare class FileReader {\n    static EMPTY: number;\n    static LOADING: number;\n    static DONE: number;\n    static READ_CHUNK_SIZE: number;\n    readyState: number;\n    error: Error;\n    result: string | ArrayBuffer;\n    onloadstart: (evt: ProgressEvent) => void;\n    onprogress: (evt: ProgressEvent) => void;\n    onload: (evt: ProgressEvent) => void;\n    onerror: (evt: ProgressEvent) => void;\n    onloadend: (evt: ProgressEvent) => void;\n    onabort: (evt: ProgressEvent) => void;\n    abort(): void;\n    readAsText(fe: IFile, encoding?: string): void;\n    readAsDataURL(fe: IFile): void;\n    readAsBinaryString(fe: IFile): void;\n    readAsArrayBuffer(fe: IFile): void;\n    /**\n     * @hidden\n     */\n    [key: string]: any;\n}\n/**\n * @name File\n * @premier filesystem\n * @description\n * This plugin implements a File API allowing read/write access to files residing on the device.\n *\n * The File class implements static convenience functions to access files and directories.\n *\n * Example:\n * ```\n * import { File } from '@ionic-native/file/ngx';\n *\n * constructor(private file: File) { }\n *\n * ...\n *\n * this.file.checkDir(this.file.dataDirectory, 'mydir').then(_ => console.log('Directory exists')).catch(err =>\n *   console.log('Directory doesn't exist'));\n *\n * ```\n *\n *  This plugin is based on several specs, including : The HTML5 File API http: //www.w3.org/TR/FileAPI/\n *  The (now-defunct) Directories and System extensions Latest: http: //www.w3.org/TR/2012/WD-file-system-api-20120417/\n *  Although most of the plugin code was written when an earlier spec was current: http:\n *   //www.w3.org/TR/2011/WD-file-system-api-20110419/ It also implements the FileWriter spec : http:\n *   //dev.w3.org/2009/dap/file-system/file-writer.html\n *  @interfaces\n *  IFile\n *  Entry\n *  DirectoryEntry\n *  DirectoryReader\n *  FileSystem\n */\nexport declare class File extends IonicNativePlugin {\n    /**\n     *  Read-only directory where the application is installed.\n     */\n    applicationDirectory: string;\n    /**\n     *  Read-only directory where the application is installed.\n     */\n    applicationStorageDirectory: string;\n    /**\n     * Where to put app-specific data files.\n     */\n    dataDirectory: string;\n    /**\n     * Cached files that should survive app restarts.\n     * Apps should not rely on the OS to delete files in here.\n     */\n    cacheDirectory: string;\n    /**\n     * Android: the application space on external storage.\n     */\n    externalApplicationStorageDirectory: string;\n    /**\n     *  Android: Where to put app-specific data files on external storage.\n     */\n    externalDataDirectory: string;\n    /**\n     * Android: the application cache on external storage.\n     */\n    externalCacheDirectory: string;\n    /**\n     * Android: the external storage (SD card) root.\n     */\n    externalRootDirectory: string;\n    /**\n     * iOS: Temp directory that the OS can clear at will.\n     */\n    tempDirectory: string;\n    /**\n     * iOS: Holds app-specific files that should be synced (e.g. to iCloud).\n     */\n    syncedDataDirectory: string;\n    /**\n     * iOS: Files private to the app, but that are meaningful to other applications (e.g. Office files)\n     */\n    documentsDirectory: string;\n    /**\n     * BlackBerry10: Files globally available to all apps\n     */\n    sharedDirectory: string;\n    cordovaFileError: any;\n    /**\n     * Get free disk space in Bytes\n     * @returns {Promise<number>} Returns a promise that resolves with the remaining free disk space in Bytes\n     */\n    getFreeDiskSpace(): Promise<number>;\n    /**\n     * Check if a directory exists in a certain path, directory.\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} dir Name of directory to check\n     * @returns {Promise<boolean>} Returns a Promise that resolves to true if the directory exists or rejects with an\n     *   error.\n     */\n    checkDir(path: string, dir: string): Promise<boolean>;\n    /**\n     * Creates a new directory in the specific path.\n     * The replace boolean value determines whether to replace an existing directory with the same name.\n     * If an existing directory exists and the replace value is false, the promise will fail and return an error.\n     *\n     * @param {string} path  Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} dirName Name of directory to create\n     * @param {boolean} replace If true, replaces file with same name. If false returns error\n     * @returns {Promise<DirectoryEntry>} Returns a Promise that resolves with a DirectoryEntry or rejects with an error.\n     */\n    createDir(path: string, dirName: string, replace: boolean): Promise<DirectoryEntry>;\n    /**\n     * Remove a directory at a given path.\n     *\n     * @param {string} path The path to the directory\n     * @param {string} dirName The directory name\n     * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.\n     */\n    removeDir(path: string, dirName: string): Promise<RemoveResult>;\n    /**\n     * Move a directory to a given path.\n     *\n     * @param {string} path The source path to the directory\n     * @param {string} dirName The source directory name\n     * @param {string} newPath The destination path to the directory\n     * @param {string} newDirName The destination directory name\n     * @returns {Promise<DirectoryEntry|Entry>} Returns a Promise that resolves to the new DirectoryEntry object or\n     *   rejects with an error.\n     */\n    moveDir(path: string, dirName: string, newPath: string, newDirName: string): Promise<DirectoryEntry | Entry>;\n    /**\n     * Copy a directory in various methods. If destination directory exists, will fail to copy.\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above\n     * @param {string} dirName Name of directory to copy\n     * @param {string} newPath Base FileSystem of new location\n     * @param {string} newDirName New name of directory to copy to (leave blank to remain the same)\n     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.\n     */\n    copyDir(path: string, dirName: string, newPath: string, newDirName: string): Promise<Entry>;\n    /**\n     * List files and directory from a given path.\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above\n     * @param {string} dirName Name of directory\n     * @returns {Promise<Entry[]>} Returns a Promise that resolves to an array of Entry objects or rejects with an error.\n     */\n    listDir(path: string, dirName: string): Promise<Entry[]>;\n    /**\n     * Removes all files and the directory from a desired location.\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} dirName Name of directory\n     * @returns {Promise<RemoveResult>} Returns a Promise that resolves with a RemoveResult or rejects with an error.\n     */\n    removeRecursively(path: string, dirName: string): Promise<RemoveResult>;\n    /**\n     * Check if a file exists in a certain path, directory.\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} file Name of file to check\n     * @returns {Promise<boolean>} Returns a Promise that resolves with a boolean or rejects with an error.\n     */\n    checkFile(path: string, file: string): Promise<boolean>;\n    /**\n     * Creates a new file in the specific path.\n     * The replace boolean value determines whether to replace an existing file with the same name.\n     * If an existing file exists and the replace value is false, the promise will fail and return an error.\n     *\n     * @param {string} path  Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} fileName Name of file to create\n     * @param {boolean} replace If true, replaces file with same name. If false returns error\n     * @returns {Promise<FileEntry>} Returns a Promise that resolves to a FileEntry or rejects with an error.\n     */\n    createFile(path: string, fileName: string, replace: boolean): Promise<FileEntry>;\n    /**\n     * Removes a file from a desired location.\n     *\n     * @param {string} path  Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} fileName Name of file to remove\n     * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.\n     */\n    removeFile(path: string, fileName: string): Promise<RemoveResult>;\n    /**\n     * Write a new file to the desired location.\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} fileName path relative to base path\n     * @param {string | Blob | ArrayBuffer} text content, blob or ArrayBuffer to write\n     * @param {IWriteOptions} whether to replace/append to an existing file. See IWriteOptions for more information.\n     * @returns {Promise<any>} Returns a Promise that resolves to updated file entry or rejects with an error.\n     */\n    writeFile(path: string, fileName: string, text: string | Blob | ArrayBuffer, options?: IWriteOptions): Promise<any>;\n    /**\n     * Write content to FileEntry.\n     * @hidden\n     * Write to an existing file.\n     * @param {FileEntry} fe file entry object\n     * @param {string | Blob | ArrayBuffer} text text content or blob to write\n     * @param {IWriteOptions} options replace file if set to true. See WriteOptions for more information.\n     * @returns {Promise<FileEntry>}  Returns a Promise that resolves to updated file entry or rejects with an error.\n     */\n    private writeFileEntry;\n    /**\n     * Write to an existing file.\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} fileName path relative to base path\n     * @param {string | Blob} text content or blob to write\n     * @returns {Promise<void>} Returns a Promise that resolves or rejects with an error.\n     */\n    writeExistingFile(path: string, fileName: string, text: string | Blob): Promise<void>;\n    /**\n     * Read the contents of a file as text.\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} file Name of file, relative to path.\n     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string or rejects with\n     *   an error.\n     */\n    readAsText(path: string, file: string): Promise<string>;\n    /**\n     * Read file and return data as a base64 encoded data url.\n     * A data url is of the form:\n     *      data: [<mediatype>][;base64],<data>\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} file Name of file, relative to path.\n     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as data URL or rejects\n     *   with an error.\n     */\n    readAsDataURL(path: string, file: string): Promise<string>;\n    /**\n     * Read file and return data as a binary data.\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} file Name of file, relative to path.\n     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string rejects with an\n     *   error.\n     */\n    readAsBinaryString(path: string, file: string): Promise<string>;\n    /**\n     * Read file and return data as an ArrayBuffer.\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} file Name of file, relative to path.\n     * @returns {Promise<ArrayBuffer>} Returns a Promise that resolves with the contents of the file as ArrayBuffer or\n     *   rejects with an error.\n     */\n    readAsArrayBuffer(path: string, file: string): Promise<ArrayBuffer>;\n    /**\n     * Move a file to a given path.\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} fileName Name of file to move\n     * @param {string} newPath Base FileSystem of new location\n     * @param {string} newFileName New name of file to move to (leave blank to remain the same)\n     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry or rejects with an error.\n     */\n    moveFile(path: string, fileName: string, newPath: string, newFileName: string): Promise<Entry>;\n    /**\n     * Copy a file in various methods. If file exists, will fail to copy.\n     *\n     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystem above\n     * @param {string} fileName Name of file to copy\n     * @param {string} newPath Base FileSystem of new location\n     * @param {string} newFileName New name of file to copy to (leave blank to remain the same)\n     * @returns {Promise<Entry>} Returns a Promise that resolves to an Entry or rejects with an error.\n     */\n    copyFile(path: string, fileName: string, newPath: string, newFileName: string): Promise<Entry>;\n    /**\n     * @hidden\n     */\n    private fillErrorMessage;\n    /**\n     * Resolves a local file system URL\n     * @param fileUrl {string} file system url\n     * @returns {Promise<Entry>}\n     */\n    resolveLocalFilesystemUrl(fileUrl: string): Promise<Entry>;\n    /**\n     * Resolves a local directory url\n     * @param directoryUrl {string} directory system url\n     * @returns {Promise<DirectoryEntry>}\n     */\n    resolveDirectoryUrl(directoryUrl: string): Promise<DirectoryEntry>;\n    /**\n     * Get a directory\n     * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method\n     * @param directoryName {string} Directory name\n     * @param flags {Flags} Options\n     * @returns {Promise<DirectoryEntry>}\n     */\n    getDirectory(directoryEntry: DirectoryEntry, directoryName: string, flags: Flags): Promise<DirectoryEntry>;\n    /**\n     * Get a file\n     * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method\n     * @param fileName {string} File name\n     * @param flags {Flags} Options\n     * @returns {Promise<FileEntry>}\n     */\n    getFile(directoryEntry: DirectoryEntry, fileName: string, flags: Flags): Promise<FileEntry>;\n    private readFile;\n    /**\n     * @hidden\n     */\n    private remove;\n    /**\n     * @hidden\n     */\n    private move;\n    /**\n     * @hidden\n     */\n    private copy;\n    /**\n     * @hidden\n     */\n    private readEntries;\n    /**\n     * @hidden\n     */\n    private rimraf;\n    /**\n     * @hidden\n     */\n    private createWriter;\n    /**\n     * @hidden\n     */\n    private write;\n    /**\n     * @hidden\n     */\n    private writeFileInChunks;\n}\n"]}