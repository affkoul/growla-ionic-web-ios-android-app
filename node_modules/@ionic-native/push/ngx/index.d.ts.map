{"version":3,"file":"index.d.ts","sources":["index.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { IonicNativePlugin } from '@ionic-native/core';\nimport { Observable } from 'rxjs';\nexport declare type EventResponse = RegistrationEventResponse & NotificationEventResponse & Error;\nexport interface RegistrationEventResponse {\n    /**\n     * The registration ID provided by the 3rd party remote push service.\n     */\n    registrationId: string;\n}\nexport interface NotificationEventResponse {\n    /**\n     * The text of the push message sent from the 3rd party service.\n     */\n    message: string;\n    /**\n     * The optional title of the push message sent from the 3rd party service.\n     */\n    title?: string;\n    /**\n     * The number of messages to be displayed in the badge iOS or message count in the notification shade in Android.\n     * For windows, it represents the value in the badge notification which could be a number or a status glyph.\n     */\n    count: string;\n    /**\n     * The name of the sound file to be played upon receipt of the notification.\n     */\n    sound: string;\n    /**\n     * The path of the image file to be displayed in the notification.\n     */\n    image: string;\n    /**\n     * An optional collection of data sent by the 3rd party push service that does not fit in the above properties.\n     */\n    additionalData: NotificationEventAdditionalData & any;\n}\n/**\n * Loosened up with a dictionary notation, but all non-defined properties need to use (map['prop']) notation\n *\n * Ideally the developer would overload (merged declaration) this or create a new interface that would extend this one\n * so that he could specify any custom code without having to use array notation (map['prop']) for all of them.\n */\nexport interface NotificationEventAdditionalData {\n    /**\n     * Whether the notification was received while the app was in the foreground\n     */\n    foreground?: boolean;\n    collapse_key?: string;\n    coldstart?: boolean;\n    from?: string;\n    notId?: string;\n    [name: string]: any;\n}\nexport interface IOSPushOptions {\n    /**\n     * Whether to use prod or sandbox GCM setting.\n     */\n    fcmSandbox?: boolean | string;\n    /**\n     * If true the device shows an alert on receipt of notification.\n     * **Note**: the value you set this option to the first time you call the init\n     * method will be how the application always acts. Once this is set\n     * programmatically in the init method it can only be changed manually by the\n     * user in Settings>Notifications>App Name. This is normal iOS behaviour.\n     */\n    alert?: boolean | string;\n    /**\n     * If true the device sets the badge number on receipt of notification.\n     * **Note**: the value you set this option to the first time you call the init\n     * method will be how the application always acts. Once this is set\n     * programmatically in the init method it can only be changed manually by the\n     * user in Settings>Notifications>App Name. This is normal iOS behaviour.\n     */\n    badge?: boolean | string;\n    /**\n     * If true the device plays a sound on receipt of notification.\n     * **Note**: the value you set this option to the first time you call the init\n     * method will be how the application always acts. Once this is set\n     * programmatically in the init method it can only be changed manually by the\n     * user in Settings>Notifications>App Name. This is normal iOS behaviour.\n     */\n    sound?: boolean | string;\n    /**\n     * If true the badge will be cleared on app startup.\n     */\n    clearBadge?: boolean | string;\n    /**\n     * If the array contains one or more strings each string will be used to\n     * subscribe to a GcmPubSub topic.\n     * **Note**: only usable in conjunction with `senderID`.\n     */\n    topics?: string[];\n    /**\n     * The data required in order to enable Action Buttons for iOS.\n     * Action Buttons on iOS - https://github.com/phonegap/phonegap-plugin-push/blob/master/docs/PAYLOAD.md#action-buttons-1\n     */\n    categories?: CategoryArray;\n    /**\n     * If true the device will be set up to receive VoIP Push notifications and the\n     * other options will be ignored since VoIP notifications are silent\n     * notifications that should be handled in the \"notification\" event.\n     */\n    voip?: boolean | string;\n}\nexport interface CategoryArray {\n    [name: string]: CategoryAction;\n}\nexport interface CategoryAction {\n    yes?: CategoryActionData;\n    no?: CategoryActionData;\n    maybe?: CategoryActionData;\n}\nexport interface CategoryActionData {\n    callback: string;\n    title: string;\n    foreground: boolean;\n    destructive: boolean;\n    inline?: boolean;\n}\nexport interface AndroidPushOptions {\n    /**\n     * Maps to the project number in the Google Developer Console.\n     */\n    senderID?: string;\n    /**\n     * The name of a drawable resource to use as the small-icon. The name should\n     * not include the extension.\n     */\n    icon?: string;\n    /**\n     * Sets the background color of the small icon on Android 5.0 and greater.\n     * [Supported Formats](http://developer.android.com/intl/ru/reference/android/graphics/Color.html#parseColor(java.lang.String))\n     */\n    iconColor?: string;\n    /**\n     * If true it plays the sound specified in the push data or the default system\n     * sound.\n     */\n    sound?: boolean | string;\n    /**\n     * If true the device vibrates on receipt of notification.\n     */\n    vibrate?: boolean | string;\n    /**\n     * If true the icon badge will be cleared on init and before push messages are processed.\n     */\n    clearBadge?: boolean | string;\n    /**\n     * If true the app clears all pending notifications when it is closed.\n     */\n    clearNotifications?: boolean | string;\n    /**\n     * If true will always show a notification, even when the app is on the\n     * foreground.\n     */\n    forceShow?: boolean | string;\n    /**\n     * If the array contains one or more strings each string will be used to\n     * subscribe to a GcmPubSub topic.\n     */\n    topics?: string[];\n    /**\n     * The key to search for text of notification.\n     */\n    messageKey?: string;\n    /**\n     * The key to search for title of notification.\n     */\n    titleKey?: string;\n}\nexport interface BrowserPushOptions {\n    /**\n     * Optional. Your GCM API key if you are using VAPID keys.\n     */\n    applicationServerKey?: string;\n    /**\n     * URL for the push server you want to use.\n     * Default: http://push.api.phonegap.com/v1/push  Optional.\n     */\n    pushServiceURL?: string;\n}\nexport interface PushOptions {\n    ios?: IOSPushOptions;\n    android?: AndroidPushOptions;\n    windows?: any;\n    browser?: BrowserPushOptions;\n}\nexport declare type Priority = 1 | 2 | 3 | 4 | 5;\nexport declare type Visibility = 0 | 1 | -1;\nexport interface Channel {\n    id: string;\n    description: string;\n    importance: Priority;\n    sound?: string;\n    vibration?: boolean | number[];\n    visibility?: Visibility;\n    badge?: boolean;\n}\nexport declare type PushEvent = string;\n/**\n * @name Push\n * @description\n * Register and receive push notifications.\n *\n * Requires Cordova plugin: `phonegap-plugin-push`. For more info, please see the [Push plugin docs](https://github.com/phonegap/phonegap-plugin-push).\n *\n * For TypeScript users, see the [Push plugin docs about using TypeScript for custom notifications](https://github.com/phonegap/phonegap-plugin-push/blob/master/docs/TYPESCRIPT.md).\n *\n * @usage\n * ```typescript\n * import { Push, PushObject, PushOptions } from '@ionic-native/push/ngx';\n *\n * constructor(private push: Push) { }\n *\n * ...\n *\n *\n * // to check if we have permission\n * this.push.hasPermission()\n *   .then((res: any) => {\n *\n *     if (res.isEnabled) {\n *       console.log('We have permission to send push notifications');\n *     } else {\n *       console.log('We do not have permission to send push notifications');\n *     }\n *\n *   });\n *\n * // Create a channel (Android O and above). You'll need to provide the id, description and importance properties.\n * this.push.createChannel({\n *  id: \"testchannel1\",\n *  description: \"My first test channel\",\n *  // The importance property goes from 1 = Lowest, 2 = Low, 3 = Normal, 4 = High and 5 = Highest.\n *  importance: 3,\n *  //badge is used to if badge appears on the app icon see https://developer.android.com/reference/android/app/NotificationChannel.html#setShowBadge(boolean).\n *  //false = no badge on app icon.\n *  //true = badge on app icon\n *  badge: false\n * }).then(() => console.log('Channel created'));\n *\n * // Delete a channel (Android O and above)\n * this.push.deleteChannel('testchannel1').then(() => console.log('Channel deleted'));\n *\n * // Return a list of currently configured channels\n * this.push.listChannels().then((channels) => console.log('List of channels', channels))\n *\n * // to initialize push notifications\n *\n * const options: PushOptions = {\n *    android: {},\n *    ios: {\n *        alert: 'true',\n *        badge: true,\n *        sound: 'false'\n *    },\n *    windows: {},\n *    browser: {\n *        pushServiceURL: 'http://push.api.phonegap.com/v1/push'\n *    }\n * }\n *\n * const pushObject: PushObject = this.push.init(options);\n *\n *\n * pushObject.on('notification').subscribe((notification: any) => console.log('Received a notification', notification));\n *\n * pushObject.on('registration').subscribe((registration: any) => console.log('Device registered', registration));\n *\n * pushObject.on('error').subscribe(error => console.error('Error with Push plugin', error));\n *\n *\n * ```\n *\n * @interfaces\n * RegistrationEventResponse\n * NotificationEventResponse\n * NotificationEventAdditionalData\n * IOSPushOptions\n * AndroidPushOptions\n * BrowserPushOptions\n * PushOptions\n */\nexport declare class Push extends IonicNativePlugin {\n    /**\n     * Init push notifications\n     * @param options {PushOptions}\n     * @return {PushObject}\n     */\n    init(options: PushOptions): PushObject;\n    /**\n     * Check whether the push notification permission has been granted.\n     * @return {Promise<{isEnabled: boolean}>} Returns a Promise that resolves with an object with one property: isEnabled, a boolean that indicates if permission has been granted.\n     */\n    hasPermission(): Promise<{\n        isEnabled: boolean;\n    }>;\n    /**\n     * Create a new notification channel for Android O and above.\n     * @param channel {Channel}\n     */\n    createChannel(channel?: Channel): Promise<any>;\n    /**\n     * Delete a notification channel for Android O and above.\n     * @param id {string}\n     */\n    deleteChannel(id?: string): Promise<any>;\n    /**\n     * Returns a list of currently configured channels.\n     * @return {Promise<Channel[]>}\n     */\n    listChannels(): Promise<Channel[]>;\n}\n/**\n * @hidden\n */\nexport declare class PushObject {\n    private _objectInstance;\n    constructor(options: PushOptions);\n    /**\n     * Adds an event listener\n     * @param event {string}\n     * @return {Observable<EventResponse>}\n     */\n    on(event: PushEvent): Observable<EventResponse>;\n    /**\n     * The unregister method is used when the application no longer wants to receive push notifications.\n     * Beware that this cleans up all event handlers previously registered,\n     * so you will need to re-register them if you want them to function again without an application reload.\n     */\n    unregister(): Promise<any>;\n    /**\n     * Set the badge count visible when the app is not running\n     *\n     * The count is an integer indicating what number should show up in the badge.\n     * Passing 0 will clear the badge.\n     * Each notification event contains a data.count value which can be used to set the badge to correct number.\n     * @param count\n     */\n    setApplicationIconBadgeNumber(count?: number): Promise<any>;\n    /**\n     * Get the current badge count visible when the app is not running\n     * successHandler gets called with an integer which is the current badge count\n     */\n    getApplicationIconBadgeNumber(): Promise<number>;\n    /**\n     * iOS only\n     * Tells the OS that you are done processing a background push notification.\n     * successHandler gets called when background push processing is successfully completed.\n     * @param [id]\n     */\n    finish(id?: string): Promise<any>;\n    /**\n     * Tells the OS to clear all notifications from the Notification Center\n     */\n    clearAllNotifications(): Promise<any>;\n    /**\n     * The subscribe method is used when the application wants to subscribe a new topic to receive push notifications.\n     * @param topic {string} Topic to subscribe to.\n     * @return {Promise<any>}\n     */\n    subscribe(topic: string): Promise<any>;\n    /**\n     * The unsubscribe method is used when the application no longer wants to receive push notifications from a specific topic but continue to receive other push messages.\n     * @param topic {string} Topic to unsubscribe from.\n     * @return {Promise<any>}\n     */\n    unsubscribe(topic: string): Promise<any>;\n}\n"]}